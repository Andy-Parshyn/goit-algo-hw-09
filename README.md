# goit-algo-hw-09

## Порівняння алгоритмів розміну монет

### Опис задачі
Реалізовано два алгоритми для задачі розміну монет:
1. **Жадібний алгоритм** (`find_coins_greedy`) - швидкий, але не завжди оптимальний
2. **Динамічне програмування** (`find_min_coins`) - завжди знаходить мінімальну кількість монет

### Результати тестування

Тестування проводилось на номіналах монет: `[50, 25, 10, 5, 2, 1]`

#### Приклад для суми 113:
- **Жадібний алгоритм**: `{50: 2, 10: 1, 2: 1, 1: 1}` - 5 монет
- **Динамічне програмування**: `{50: 2, 10: 1, 2: 1, 1: 1}` - 5 монет
- **Час виконання**: Жадібний ~0.000002 сек, DP ~0.000050 сек (DP в ~25 разів повільніше)

#### Приклад для суми 178:
- **Жадібний алгоритм**: `{50: 3, 25: 1, 2: 1, 1: 1}` - 6 монет
- **Динамічне програмування**: `{50: 3, 25: 1, 2: 1, 1: 1}` - 6 монет
- **Час виконання**: Жадібний ~0.000002 сек, DP ~0.000080 сек (DP в ~40 разів повільніше)

#### Приклад для суми 500:
- **Жадібний алгоритм**: `{50: 10}` - 10 монет
- **Динамічне програмування**: `{50: 10}` - 10 монет
- **Час виконання**: Жадібний ~0.000002 сек, DP ~0.000220 сек (DP в ~110 разів повільніше)

#### Приклад для суми 1000:
- **Жадібний алгоритм**: `{50: 20}` - 20 монет
- **Динамічне програмування**: `{50: 20}` - 20 монет
- **Час виконання**: Жадібний ~0.000002 сек, DP ~0.000450 сек (DP в ~225 разів повільніше)

### Висновки


#### Переваги та недоліки:

**Жадібний алгоритм:**
-  Дуже швидкий (константний час виконання незалежно від суми)
-  Мінімальне використання пам'яті
-  Простий у реалізації
-  Для стандартних монет ([50, 25, 10, 5, 2, 1]) завжди дає оптимальний результат
-  Не гарантує оптимальність для довільних наборів монет

**Динамічне програмування:**
-  Завжди знаходить оптимальне рішення
-  Працює для будь-яких наборів номіналів
-  Значно повільніший (час зростає лінійно з сумою)
-  Використовує додаткову пам'ять пропорційно сумі
-  Складніший у реалізації

#### Рекомендації по використанню:

1. **Використовуйте жадібний алгоритм**, якщо:
   - Працюєте зі стандартними монетами
   - Потрібна максимальна швидкість
   - Обробляєте великі суми або велику кількість запитів

2. **Використовуйте динамічне програмування**, якщо:
   - Маєте нестандартний набір номіналів
   - Необхідна гарантія оптимальності
   - Сума невелика (до кількох тисяч)

Для даного набору монет `[50, 25, 10, 5, 2, 1]` жадібний алгоритм є кращим вибором через його швидкість та той факт, що він дає оптимальні результати.
